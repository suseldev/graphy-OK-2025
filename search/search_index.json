{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Graphy","text":"<p>Project made for combinatorial optimization classes implementing heuristic algorithms searching for integral graphs.</p>"},{"location":"#build","title":"Build","text":"<p>Graphy is written in C and uses the GNU Scientific Library (GSL) for spectral computations.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>GCC compiler</li> <li>GNU Make</li> <li>GSL (libgsl)</li> </ul>"},{"location":"#installing-gsl","title":"Installing GSL","text":"<ul> <li>Debian-based systems:   <code>sudo apt install libgsl-dev</code></li> <li>Arch Linux based systems:   <code>sudo pacman -S gsl</code></li> </ul>"},{"location":"#compilation","title":"Compilation","text":"<p>To build all binaries, run:</p> <pre><code>$ make all\n</code></pre> <p>The compiled executables will be placed in <code>bin/</code> directory.</p>"},{"location":"#cleaning-build-artifacts","title":"Cleaning build artifacts","text":"<p>To clean build artifacts, run:</p> <pre><code>$ make clean\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Each algorithm is provided as a separate executable. All programs share the same command-line interface. Generated output is in the graph6 format.</p>"},{"location":"#general-form","title":"General form","text":"<p><code>./graphy_&lt;algorithm&gt; [-qI] [-s &lt;seed&gt;] [-w &lt;outfile] n k</code></p> <p>where:</p> <ul> <li><code>n</code> (required): number of vertices</li> <li><code>k</code> (required): number of edges</li> <li><code>-q</code>: Quiet mode: prints only generated graphs in graph6 format.</li> <li><code>-I</code>: Disables internal integrity checks, returning the first generated graph without verifying whether its spectrum is integral. Useful when piping the output to external tools (e.g. <code>sito5</code>).</li> <li><code>-s</code>: Sets the seed for initializing RNG.</li> <li><code>-w &lt;outfile&gt;</code>: Writes generated graphs to a file instead of a standard output</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>Generate a random connected integral graph with 6 vertices and 9 edges:</p> <p><code>./graphy_random 6 9</code></p> <p>Run the greedy heuristic with quiet output and a fixed seed:</p> <p><code>./graphy_greedy -q -s 12345 6 9</code></p> <p>Generate graphs and pipe them to an external filter:</p> <p><code>./graphy_rand_greedy -qI 6 9 | ./sito5</code></p>"},{"location":"algorithms/","title":"Implemented algorithms","text":""},{"location":"algorithms/#spectral-algorithms-srcspectrumc","title":"Spectral algorithms (<code>src/spectrum.c</code>)","text":""},{"location":"algorithms/#eigenvalues-calculation","title":"Eigenvalues calculation","text":"<p>Eigenvalues calculation is done using GSL functions.</p>"},{"location":"algorithms/#calculation-of-spectral-integrality-score","title":"Calculation of spectral integrality score","text":"<p>To guide heuristic algorithms during graph construction, a numerical score is assigned to each candidate graph.</p> <ul> <li> <p>For each eigenvalue, its distance to the nearest integer is computed.</p> <ul> <li> <p>If an eigenvalue is close to one (smaller than <code>EIGEN_T</code>, found in <code>include/constants.h</code>), a <code>1</code> is added to the score.</p> </li> <li> <p>Otherwise, the score is decreased proportionally to the distance from the nearest integer:</p> <ul> <li><code>score = score - NON_INTEGRAL_PENALTY*(eigenvalue-round(eigenvalue))</code></li> </ul> </li> </ul> </li> </ul> <p><code>NON_INTEGRAL_PENALTY</code> can be modified in <code>include/constants.h</code> file.</p>"},{"location":"algorithms/#heuristic-algorithms","title":"Heuristic algorithms","text":""},{"location":"algorithms/#random-srcheuristic_randomc","title":"Random (<code>src/heuristic_random.c</code>)","text":"<p>1) We start from the random tree to guarantee connectivity. This is done by iteratively connecting each vertex i (<code>i=1, ..., n-1</code>) to a randomly chosen vertex (<code>0, ..., i-1</code>)</p> <p>2) While the number of edges is smaller than <code>k</code>, random pairs of distinct vertices is selected. If an edge does not already exist, it is added to the graph.</p> <p>3) If integrality checking is enabled, the selected graph is tested for spectral integrality.</p>"},{"location":"algorithms/#greedy-srcheuristic_greedyc","title":"Greedy (<code>src/heuristic_greedy.c</code>)","text":"<p>1) We start from the random tree to guarantee connectivity, using the same algorithm as before.</p> <p>2) While the number of edges is smaller than <code>k</code>, the algorithm considers all possible edges not already present in the graph, temporarily adding it, calculating the integrality score and removing it.. The edge with the highest score improvement is then added to the graph.</p> <p>3) If integrality checking is enabled, the selected graph is tested for spectral integrality.</p>"},{"location":"algorithms/#greedy-random-srcheuristic_rand_greedyc","title":"Greedy Random (<code>src/heuristic_rand_greedy.c</code>)","text":"<p>1) We again start from the random tree.</p> <p>2) While the number of edges is smaller than <code>k</code>, the algorithm performs one of two actions:</p> <ul> <li> <p>with probability <code>pRand</code>: a random missing edge is selected and added to the graph</p> </li> <li> <p>with probability <code>1-pRand</code>: the greedy strategy is applied.</p> </li> </ul> <p>3) If integrality checking is enabled, the selected graph is tested for spectral integrality.</p> <p>The parameter <code>pRand</code> (found in <code>include/constants.h</code>, named <code>RANDGREEDY_PRAND</code>) controls the balance:</p> <ul> <li> <p><code>pRand=0</code> reduces the algorithm to the pure greedy heuristics</p> </li> <li> <p><code>pRand=1</code> reduces it to the purely random construction</p> </li> <li> <p>intermediate values mix both approaches to the problem.</p> </li> </ul>"},{"location":"code/","title":"Code documentation","text":""},{"location":"code/#cli-includeclih","title":"cli (<code>include/cli.h</code>)","text":"<ul> <li> <p><code>CliConfig</code> (<code>struct</code>): Structure representing parsed command line options.</p> </li> <li> <p><code>n</code> (<code>int</code>): Number of vertices in the generated graph.</p> </li> <li> <p><code>k</code> (<code>int</code>): Number of edges in the generated graph.</p> </li> <li> <p><code>seed</code> (<code>unsigned int</code>): Seed used to initialize the RNG. If set to <code>0</code>, a default value (<code>time(NULL)</code>) is used.</p> </li> <li> <p><code>quiet</code> (<code>bool</code>): Controls output verbosity (if <code>true</code>, only graph6 representations are printed).</p> </li> <li> <p><code>integralityCheck</code> (<code>bool</code>): Controls whether generated graphs are checked for spectral integrity.</p> </li> <li> <p><code>outFile</code> (<code>const char *</code>): Path to the output file. If <code>NULL</code>, output is written to standard output</p> </li> <li> <p><code>CliConfig cliParse(int argc, char **argv)</code>: Parses command line arguments and returns populated CliConfig structure. Parameters <code>argc</code> and <code>argv</code> are argument count and argument vector passed to main. Returns fully initialized CliConfig structure. This function should terminate the program with an error message on invalid input.</p> </li> </ul>"},{"location":"code/#config-includeconfigh","title":"config (<code>include/config.h</code>)","text":"<ul> <li><code>INTEGRALITY_CHECK_ENABLED</code> (<code>bool</code>):</li> </ul> <p>Controls whether the generated graphs are filtered by the integrality condition before being returned.</p> <ul> <li> <p><code>true</code>: All heuristic methods verify whether the generated graph is spectrally integral. Only graphs satisfying this condition will be returned.</p> </li> <li> <p><code>false</code>: All generated graphs are returned without internal verification. This mode is intended for external post-processing (for example piping the output to tools such as <code>sito5</code>).</p> </li> <li> <p><code>QUIET</code> (<code>bool</code>):</p> </li> </ul> <p>Controls the output format.</p> <ul> <li> <p><code>true</code>: Displays only generated graphs in graph6 format.</p> </li> <li> <p><code>false</code>: Displays additional debug information and generated graphs.</p> </li> </ul>"},{"location":"code/#constants-includeconstantsh","title":"constants (<code>include/constants.h</code>)","text":"<ul> <li> <p><code>EIGEN_T</code> (<code>double</code>): Numerical tolerance used when checking whether an eigenvalue is considered integral. (defaults to <code>1e-15</code>).</p> </li> <li> <p><code>NON_INTEGRAL_PENALTY</code> (<code>double</code>): Penalty factor when computing the integrality score of non-integral eigenvalues.</p> </li> <li> <p><code>RANDGREEDY_PRAND</code> (<code>double</code>): pRand parameter used for greedy random algorithm.</p> </li> </ul>"},{"location":"code/#graph-includegraphh","title":"graph (<code>include/graph.h</code>)","text":"<ul> <li> <p><code>Graph</code> (<code>struct</code>): Structure describing the graph</p> </li> <li> <p><code>n</code> (<code>int</code>): number of vertices</p> </li> <li> <p><code>edges</code> (<code>int</code>): number of edges</p> </li> <li> <p><code>adj</code> (<code>int**</code>): adjacency matrix</p> </li> </ul>"},{"location":"code/#creating-and-destroying-graphs","title":"Creating and destroying graphs","text":"<ul> <li> <p><code>Graph *graphCreate(int n)</code>: Creates the empty graph and returns it.</p> </li> <li> <p><code>void graphFree(Graph *g)</code>: Destroys the graph, freeing the memory</p> </li> </ul>"},{"location":"code/#basic-graph-operations","title":"Basic graph operations","text":"<ul> <li> <p><code>bool graphAddEdge(Graph *g, int a, int b)</code>: Adds the edge <code>(a, b)</code> to graph <code>g</code>. Returns <code>true</code> if operation was successful, <code>false</code> if not.</p> </li> <li> <p><code>bool graphAddEdge(Graph *g, int a, int b)</code>: Removes the edge <code>(a, b)</code> from graph <code>g</code> Returns <code>true</code> if operation was successful, <code>false</code> if not.</p> </li> <li> <p><code>bool graphHasEdge(Graph *g, int a, int b)</code>: Checks whether the edge exists in the graph. Returns <code>true</code> if edge exists, <code>false</code> if not.</p> </li> </ul>"},{"location":"code/#additional-graph-utilities","title":"Additional graph utilities","text":"<ul> <li><code>void graphClear(Graph *g)</code>: Clears the graph while keeping the allocated structure.</li> <li><code>Graph *graphCopy(const Graph *g)</code>: Copies the graph. Returns copied graph.</li> </ul>"},{"location":"code/#graph-gsl-includegraph_gslh","title":"Graph GSL (<code>include/graph_gsl.h</code>)","text":"<ul> <li><code>gsl_matrix graphConvertToGSLMatrix(Graph *g)</code>: Converts the graph adjacency list to GSL matrix. Returns: <code>gsl_matrix</code>.</li> </ul>"},{"location":"code/#heuristics-common-includeheuristics_commonh","title":"Heuristics Common (<code>include/heuristics_common.h</code>)","text":"<ul> <li><code>void graphMakeRandomTree(Graph *g)</code>: Expects an empty graph. Creates a random tree structure using the algorithm described in algorithms section.</li> </ul>"},{"location":"code/#heuristics-greedy-includeheuristics_greedyh","title":"Heuristics Greedy (<code>include/heuristics_greedy.h</code>)","text":"<ul> <li> <p><code>bool greadyAddBestEdge(Graph *g)</code>: Performs a single greedy step by selecting and adding the edge that maximizes the integrity score. Returns <code>true</code> if an edge was successfuly added, <code>false</code> otherwise.</p> </li> <li> <p><code>Graph *heuristicsGreedyGenerateGraph(int n, int k)</code>: Generates a connected graph with <code>n</code> vertices and <code>k</code> edges using the algorithm described in algorithms section. Returns: a pointer to the generated graph or <code>NULL</code> if graph generation fails.</p> </li> <li> <p><code>Graph *heuristicsGreedyGenerateIntegralGraph(int n, int k)</code>: Repeatedly generates graphs using the greedy heuristic until a spectrally integral graph is found. Returns: a pointer to a spectrally integral graph or <code>NULL</code> if graph generation fails.</p> </li> </ul>"},{"location":"code/#heuristics-greedy-random-includeheuristics_rand_greedyh","title":"Heuristics Greedy Random (<code>include/heuristics_rand_greedy.h</code>)","text":"<ul> <li> <p><code>Graph *heuristicsRandomGreedyGenerateGraph(int n, int k, double pRand)</code>: Generates a connected graph with <code>n</code> vertices and <code>k</code> edges using the algorithm described in algorithms section. Parameter <code>pRand</code> is the probability of performing a random step. Returns: a pointer to a generated graph or <code>NULL</code> if graph generation fails.</p> </li> <li> <p><code>Graph *heuristicsRandomGreedyGenerateIntegralGraph(int n, int k, double pRand)</code>: Repeatedly generates graphs using the randomized greedy heuristic until a spectrally integral graph is found. Returns: a pointer to a spectrally integral graph or <code>NULL</code> if graph generation fails.</p> </li> </ul>"},{"location":"code/#heuristics-random-includeheuristics_randomh","title":"Heuristics Random (<code>include/heuristics_random.h</code>)","text":"<ul> <li> <p><code>Graph *heuristicsRandomGenerateGraph(int n, int k)</code>:  Generates a connected graph with <code>n</code> vertices and <code>k</code> edges using the algorithm described in algorithms section. Returns: a pointer to a generated graph or <code>NULL</code> if graph generation fails.</p> </li> <li> <p><code>Graph *heuristicsRandomGreedyGenerateIntegralGraph(int n, int k, double pRand)</code>: Repeatedly generates graphs using the <code>heuristicRandomGenerateGraph</code> until a spectrally integral graph is found. Returns: a pointer to a spectrally integral graph or <code>NULL</code> if graph generation fails.</p> </li> </ul>"},{"location":"code/#io-includeioh","title":"IO (<code>include/io.h</code>)","text":"<ul> <li><code>void graphWriteToGraph6(const Graph *g, FILE *outputFile)</code>: Exports the graph <code>g</code> to the <code>outputFile</code> in graph6 format.</li> </ul>"},{"location":"code/#spectrum-includespectrumh","title":"Spectrum (<code>include/spectrum.h</code>)","text":"<ul> <li> <p><code>bool spectrumCalculateEigenvalues(Graph *g, double *eigenValues)</code>: Computes all eigenValues of the adjacency matrix of graph <code>g</code>. Parameter <code>eigenValues</code> should be an output array of size <code>g-&gt;n</code> where computed eigenvalues will be stored. Returns <code>true</code> if computation was successful, <code>false</code> if it fails due to invalid input or allocation errors.</p> </li> <li> <p><code>double spectrumIntegralScore(Graph *g)</code>: Computes the integrality score of the graph spectrum. Definition of the score function can be found in algorithms section.</p> </li> <li> <p><code>bool spectrumIsIntegral(Graph *g)</code>: Checks whether the spectrum of graph <code>g</code> is integral within a numerical tolerance (found in <code>include/constants.h</code>). Returns: <code>true</code> if all eigenvalues are integral, <code>false</code> otherwise.</p> </li> </ul>"}]}